[ { "title": "How to sort an array with Insertion Sort?", "url": "/posts/how-to-sort-an-array-with-insertion-sort/", "categories": "Algorithms", "tags": "arrays, sorting", "date": "2023-02-04 02:57:00 +0100", "snippet": "IntroductionThe insertion sort still executes in O(N^2) time, but sort performs better thanBubble Sort and Selection Sort. It’s an elementary sort algorithm, nottoo complex, and it’s often used as the final stage of more sophisticated sorts,such as quicksort.How it works?Once more, the array is divided into two logical partitions: sorted partion and unsorted partition.Before starting, we assume we have a logical partition of size 1. As this partition just have one item,it is automatically ordered. How to do that? Simple:int[]intArray={20,35,-15,7,55,1,-22};for(int unsortedIndex=1;unsortedIndex&amp;lt;intArray.length;unsortedIndex++)In the snippet above, we have: The unsorted array The following code: for (int unsortedIndex = 1 ....Notice we are passing through the unsorted array starting at the position 1. That means we consider theposition 0 our sorted partition already sorted! As we have a sorted partition with one element, the goal of theInsertion Sort algorithm consists in growing the sorted partition from left to right using the following steps: Get a new element from the unsorted partition Grow the sorted partition to accommodate the new element (We are not really growing because it is an in-placealgorithm, but we are growing it logically) Shift the sorted partition items to right until find a position to insert the new element. The new element will be inserted where newElement &amp;lt; array[index - 1]Let’s see the evolution of the sorting process after each completion of the outer loop: Number of Iteration Snapshot of the array 1 20 35 -15 7 55 1 -22 2 -15 20 35 7 55 1 -22 3 -15 7 20 35 55 1 -22 4 -15 7 20 35 55 1 -22 5 -15 1 7 20 35 55 -22 6 -22 -15 1 7 20 35 55 Characteristics In-place algorithm O(n^2) time complexity or quadratic It will take: 100 steps to sort 10 items (10 x 10) 10.000 steps to sort 100 items (100 x 100) 1.000.000 steps to sort 1000 items (1000 x 1000) Stable algorithm → the original order of duplicated items will be preserved.Implementationpackage io.ellisonalves.insertionsort;public class InsertionSortApp { public static void main(String[] args) { int[] intArray = {20, 35, -15, 7, 55, 1, -22}; for (int unsortedIndex = 1; unsortedIndex &amp;lt; intArray.length; unsortedIndex++) { int newElement = intArray[unsortedIndex]; int sortedIndex; for (sortedIndex = unsortedIndex; sortedIndex &amp;gt; 0 &amp;amp;&amp;amp; newElement &amp;lt; intArray[sortedIndex - 1]; sortedIndex--) intArray[sortedIndex] = intArray[sortedIndex - 1]; // shift numbers to right intArray[sortedIndex] = newElement; printArray(intArray); } } private static void printArray(int[] intArray) { for (int j : intArray) System.out.print(j + &quot; &quot;); System.out.println(); }}ConclusionAs always, I encourage you to modify this example and find out other ways of implementing the same logic. That approachis excellent when we are learning any kind of Algorithms.Hope it helps you!Stay tuned for more posts regarding algorithms!" }, { "title": "How to sort an array with Selection Sort?", "url": "/posts/how-to-sort-an-array-with-selection-sort/", "categories": "Algorithms", "tags": "arrays, sorting", "date": "2023-02-02 02:22:00 +0100", "snippet": "IntroductionThe selection sort improves on the bubble sort by reducing the number of swaps necessary from O(n^2) to O(N). Thisimprovement can be significant for large records that must be physically moved around in memory. (Not the case in Java,where references are moved, not entire objects).The number of comparisons continues O(n^2).How it works?This algorithm will pass through all the array comparing neighbors in order to find the largest one. Once this processis finished, it will compare if the selected item is larger than the last item of the unsorted partition. If yes,the numbers will be swapped, the unsorted partition will be decremented by one, meaning the sorted partition willgrow from right to left.Here is a table showing this right to left movement happening: # of swaps Array’s Snapshot 1 20 35 -15 7 -22 1 55 2 20 1 -15 7 -22 35 55 3 -22 1 -15 7 20 35 55 4 -22 -15 1 7 20 35 55 Characteristics In-place algorithm because → That means the algorithm doesn’t need more than the initial amount of memory tosort the array; O(\\(n^2\\)) time complexity or quadratic → For each element in the array we traverse N elements. In that case,the worst case would traverse the whole array twice in order to get it ordered. For example, it will take: 100 steps to sort 10 items (10 x 10); 10.000 steps to sort 100 items (100 x 100); 1.000.000 steps to sort 1000 items (1000 x 1000); Fewer swaps → It doesn’t require as much swapping as bubble sort because it only swaps when find the nextlargest element in the unsorted partition; Usually performs better than bubble sort → but it will depend on how the array being sorted is. For example,if you compare both worse cases it performs a bit better because this algorithm will probably do fewer swaps thanbubble sort. Unstable → There is no guarantee that their original order relative to each other will be preserved. It isvery possible that the second duplicated value will be placed in front of its twin;Implementationpackage io.ellisonalves.selectsort;public class SelectionSortApp { public static void main(String[] args) { int[] intArray = {20, 35, -15, 7, 55, 1, -22}; for (int lastUnsortedIndex = intArray.length - 1; lastUnsortedIndex &amp;gt; 0; lastUnsortedIndex--) { int largestNumberIndex = 0; for (int currentIndex = largestNumberIndex + 1; currentIndex &amp;lt;= lastUnsortedIndex; currentIndex++) { if (intArray[largestNumberIndex] &amp;lt; intArray[currentIndex]) { largestNumberIndex = currentIndex; } } swap(intArray, largestNumberIndex, lastUnsortedIndex); } printArray(intArray); } private static void printArray(int[] intArray) { for (int j : intArray) System.out.print(j + &quot; &quot;); System.out.println(); } private static void swap(int[] array, int newLargestIndex, int lastUnsortedIndex) { if (newLargestIndex == lastUnsortedIndex) return; int temp = array[newLargestIndex]; array[newLargestIndex] = array[lastUnsortedIndex]; array[lastUnsortedIndex] = temp; printArray(array); }}ConclusionNotice that I’ve chosen for an implementation that grows the sorted partition from right to left, but I encourage youto modify this example in order to make it grow from left to right.Hope it helps you!Stay tuned for more posts regarding algorithms!" }, { "title": "How to sort an array with Bubble sort", "url": "/posts/how-to-sort-an-array-with-bubble-sort/", "categories": "Algorithms", "tags": "arrays, sorting", "date": "2023-01-31 23:14:00 +0100", "snippet": "IntroductionI think this one was the first algorithm I’ve learned in college. The performance of this algorithm degrades quickly asthe number of items you need to sort grows. However, this algorithm gives you a good idea ofwhat algorithm thinking is.How it works?The main idea of this algorithm is to divide the array into two logical partitions (sorted and unsorted) and,traverse unsorted partition verifying if the item (a[i]) is bigger than the other (a[j]) right next to it. Ifthat condition is true, the items are swapped and the sorted partition grows from right to left.Consider an unsorted array with the given elements: 20, 35, -15, 7, 55, 1, -22.We will define two indexes to keep track of the logical partitions aforementioned: Last unsorted Partition Index → starts at the end of the array (length - 1). Used for traversing the arrayfromright to left, Current Index → starts at the beginning of the array (i = 0). Used for traversing the array fromleft to rightSee a snapshot of the array after each iteration over the unsorted partition. Notice that the bigger numbers are placedordered from right to left. Iteration # Sorted Partition Index Unsorted Partition Index Array Snapshot 1 0 6 -22 20 -15 7 35 1 55 2 1 5 -22 1 -15 7 20 35 55 3 2 4 -22 1 -15 7 20 35 55 4 3 3 -22 -15 1 7 20 35 55 5 4 2 -22 -15 1 7 20 35 55 6 5 1 -22 -15 1 7 20 35 55 You will also notice that some items find their positions before the end of the algorithm. This happens because the algorithm does many swaps and eventually some items will find the correct position before the end of the algorithm.Characteristics In-place algorithm. Means that the ordering is done without the need of using more arrays or other data structures. O(n^2) time complexity - quadratic Algorithm degrades quickly as the number of elements in the array growsExamplepackage io.ellisonalves.bubblesort;public class BubbleSortApp { public static void main(String[] args) { int[] intArray = {20, 35, -15, 7, 55, 1, -22}; for (int lastUnsortedIndex = intArray.length - 1; lastUnsortedIndex &amp;gt; 0; lastUnsortedIndex--) { for (int currentIndex = 0; currentIndex &amp;lt; lastUnsortedIndex; currentIndex++) if (intArray[currentIndex] &amp;gt; intArray[lastUnsortedIndex]) swap(intArray, currentIndex, lastUnsortedIndex); } printArray(intArray); } public static void swap(int[] array, int i, int j) { if (i == j) { return; } int temp = array[i]; array[i] = array[j]; array[j] = temp; } private static void printArray(int[] intArray) { for (int j : intArray) System.out.print(j + &quot; &quot;); System.out.println(); }}ConclusionThis is a very simple algorithm that helps you on understanding the basics of how to sort arrays.For now, I want to you to keep posted because I want to explore more this subject." }, { "title": "Disabling TRACE request with spring", "url": "/posts/disabling-trace-method-requests-with-spring/", "categories": "Spring", "tags": "springboot", "date": "2023-01-20 22:01:00 +0100", "snippet": "IntroductionRecently I got a request for disabling TRACE method calls in the application for security reasons because an attacker could have access to some information that would allow them to find a breach.SolutionConsidering the application is using spring boot, there are some steps to follow.Change application.propertiesThe following line should be added in the application.properties file:spring.mvc.dispatch-trace-request=trueThis change is required to tell spring that the TRACE requests should go now through the FrameworkServlet doService method just as other methods. So we will be able to intercept it.Configuration Spring MVCIn order to configure Spring MVC, we just need to create a configuration class extending WebMvcConfigurer. Here you can see an example in kotlin.@Configurationclass WebConfig : WebMvcConfigurer { override fun addInterceptors(registry: InterceptorRegistry) { registry.addInterceptor(TraceMethodInterceptor()).addPathPatterns(&quot;/**&quot;) } private class TraceMethodInterceptor : HandlerInterceptor { override fun preHandle( request: HttpServletRequest, response: HttpServletResponse, handler: Any, ): Boolean { if (HttpMethod.TRACE.matches(request.method)) { response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED) return false } return true } }}In the example we are doing the following: Creating a new interceptor called TraceMethodInterceptor which will always responds as METHOD_NOT_ALLOWED when any TRACE request is executed againist our application Adding the interceptor in spring Adding the pattern that will be intercepted with addPathPatterns(&quot;/**&quot;)ConclusionThat’s should be enough for disabling incoming TRACE requests in our application. I also created a repository in github so you can have all the details of the application such as tests for verifying that the implementation works.Hope it helps! :)" }, { "title": "Junit and Multi-Threading Scenarios", "url": "/posts/junit-and-multithreading-scenarios/", "categories": "Java", "tags": "UnitTesting, MultiThreading", "date": "2021-11-23 19:15:00 +0100", "snippet": "Not a long time ago I was exploring how to create an unit test for multi-threading scenarios without the need of using external libraries. I was able to achieve it by doing a pair programming session with a colleague and we had a lot of fun!That experience was so cool that I decided to invest more time on this particular problem to refactor and share what I’ve learned. Let’s start.The environmentThe environment used for this study is: Java 17 JUnit 5.8.1 Gradle 7.3The problemThe problem consists in persisting a set of persons into an in-memory data structure and the only requirement is: the data structure can’t have more than 10 persons.This requirement will allow us to explore what happens to the shared resource (the data structure) when there are many threads reading and writing it.Let’s start exploring it without worrying about multi-threading requirements. The outcome would be a record to represent the personpublic record Person(String name) {}and a repository to handle persistence operations of persons:public class PersonRepository { private final Set&amp;lt;Person&amp;gt; persons; public PersonRepository(Set&amp;lt;Person&amp;gt; persons) { this.persons = persons; } void persist(Person person) { if (persons.size() &amp;gt;= 10) { throw new IllegalStateException(&quot;The repository can not handle more than 10 persons&quot;); } persons.add(person); }}This implementation would work perfectly for a single thread environment but for a multi-threading environment we would experience inconsistencies due to the shared resource (Set) being read and written simultaneously without any access control policy.Let&#39;s create a failing test, so it will be possible to verify that the code is not able to handle concurrent scenarios consistently.class HandlingMultiThreadingScenarios { ExecutorService executorService; @BeforeEach void setUp() { executorService = Executors.newFixedThreadPool(3); } @AfterEach void tearDown() throws InterruptedException { executorService.shutdown(); awaitTerminationAndShutdownNow(); } @RepeatedTest(15) void shouldPersistPersonCorrectlyWithMultipleThreads() throws InterruptedException { persistManyPersonsConcurrently(15); awaitTerminationAndShutdownNow(); assertEquals(10, PERSONS.size()); } @Test void shouldPerformThePersistenceOfPersonsWithinTheGivenTimeout() { assertTimeout(Duration.ofSeconds(1), () -&amp;gt; persistManyPersonsConcurrently(20)); } private List&amp;lt;Person&amp;gt; persistManyPersonsConcurrently(int numberOfPersons) { List&amp;lt;Person&amp;gt; personList = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; numberOfPersons; i++) { final int indexCopy = i; executorService.submit(() -&amp;gt; personRepository.persist(new Person(&quot;Person n: &quot; + indexCopy))); } return personList; } private void awaitTerminationAndShutdownNow() throws InterruptedException { boolean timeout = executorService.awaitTermination(100, TimeUnit.MILLISECONDS); if (timeout) { executorService.shutdownNow(); } }} @BeforeEach and @AfterEach we create and shutdown an arbitrary number of threads before and after each test. This way we guarantee that every test will have the same initial setup. The method persistManyPersonsConcurrently(int numberOfPersons) simulates the concurrent access to persist Persons. There is a for loop that will repeat N times the same operation and we will have up to 3 threads running simultaneously. As an analogy, think that the for loop represents a number of persons withdrawing money from the same account (shared resource) using 3 distinct ATMs (thread). As there are only 3 ATMs, it means that only 3 persons can be served at the same time. @Repeated(15) Threads behave in an unpredictable way and for that reason the test must be repeated many times to make sure it is working consistently. There is no specific reason for repeating 15 times, just make sure that there are enough repetitions to verify the multi-threading behavior. The test shouldPersistPersonCorrectlyWithMultipleThreads() has the following steps: Simulate the concurrent persistence of 15 persons Wait until all the threads are finished Assert that we have only 10 persisted persons. That assertion is enough to guarantee the correctness of the program. It is time to see how the failing test case behaves after few executions. (Remember, it has to fail consistently)In the Figure 1 it is possible to prove that multi-threading is unpredictable because there are different results for the same code base. Now, it is time to work on the solution.The solutionIt is necessary think about the correctness of the program when working with multi-threading applications. For this example, correctness means that the application should behave and give the same output as a single thread application would. In order to achieve that, each thread should access the shared resource atomically - one thread at time.Therefore, a valid approach would be using the Lock interface:public class PersonRepository { private final Set&amp;lt;Person&amp;gt; persons; private final Lock lock; public PersonRepository(Set&amp;lt;Person&amp;gt; persons, Lock lock) { this.persons = persons; this.lock = lock; } void persist(Person person) { lock.lock(); try { if (persons.size() == 10) { throw new IllegalStateException(&quot;The repository can not handle more than 10 persons&quot;); } persons.add(person); } finally { lock.unlock(); } }}After adding the Lock object, the access to the shared resource is now synchronized and we have a success test!ConclusionThe objective of this post is to help people who are interested to getting started to write unit tests for multi-threading applications.Hope you liked it. :)The full code can be found on github." } ]
